<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/">
    <channel>
        <title>morpheus 的日志 Blog</title>
        <link>https://lvwei.blog/blog</link>
        <description>morpheus 的日志 Blog</description>
        <lastBuildDate>Thu, 17 Mar 2016 12:01:00 GMT</lastBuildDate>
        <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
        <generator>https://github.com/jpmonette/feed</generator>
        <item>
            <title><![CDATA[如何实现自己没实现过的需求之文本动画]]></title>
            <link>https://lvwei.blog/blog/2016/04/08/old-blog-post</link>
            <guid>/2016/04/08/old-blog-post</guid>
            <pubDate>Thu, 17 Mar 2016 12:01:00 GMT</pubDate>
            <description><![CDATA[这是一篇旧文, 当时的文风还挺不一样的。]]></description>
            <content:encoded><![CDATA[<blockquote><p>这是一篇旧文, 当时的文风还挺不一样的。</p></blockquote><p>大家好, 欢迎来到罪恶坑, 我是非知名程序员, 想跟大家说一段传统相声节目, 额, 对不起, 说错了。想跟大家分享一点关于文本和动画的东西。这不是一篇纯血统, 高、精、尖的技术文章, 但依然希望有人能像喜欢混血美女一样喜欢。</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="前言">前言<a class="hash-link" href="#前言" title="Direct link to heading">​</a></h2><p>记得以前看到过一个很赞的文字效果的动画, 类似于这样：</p><p><img src="https://cloud.githubusercontent.com/assets/3759810/13845905/1e55a5d0-ec7e-11e5-9631-68aaf6b07ba1.gif" alt="textanimation"></p><p>当时被惊艳到了, 最近偶然间又再次见到, 依然还是那么喜欢。假设我们现在需要实现这样的需求。一般碰到需求我们都会去github上看看, 俗称找轮子（github基本上只有你想不到的, 就没有它没有的）。大多数情况下, 没有问题。或者说有点小问题：轮子太多, 无从下嘴。</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="选择">选择<a class="hash-link" href="#选择" title="Direct link to heading">​</a></h2><blockquote><p>选轮子就像选姑娘, 你不知道后面等着你的是什么 -----罪恶坑小程如是说</p></blockquote><p>程序员江湖, 每位大侠的武功和套路不尽一样, 少林, 武当, 昆仑各门各派, 百花争艳。实现轮子的思路自然也不一样。有的轮子高深晦涩难懂, 功能强大, 有的清晰明了, 功能简单。不过有一点相同是, 选错了就会被坑, 只是坑大坑小问题。选轮子自然需要无比谨慎, 既要匹配需求同时也要能在掉坑里的时候填上（废话, 出bug了, 你不填, 谁填）, 要能hold住。然而填坑哪能那么简单呢, 首先轮子实现思路, 代码的结构, 运行时序你要搞清楚吧, 提供了哪些功能, 没提供哪些功能, 你要了解吧。基本上一个复杂点的轮子, 研究下来就要好些时间了。这还不包括你开会, 沟通, 解bug, 喝茶, 倒水, 上厕所, 抽烟, 骂娘, 吐槽产品需求的时间。所以, 妹子们, 不要问我们今天加不加班, 要问今天能不能在你睡前下班。（项目快上线了, 小程不加班谁加班。嗯哼。）</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="创造">创造<a class="hash-link" href="#创造" title="Direct link to heading">​</a></h2><blockquote><p>如果能用代码扮演上帝话, 苍老师的量产不是问题, 就看产品经理定的需求是拟物还是扁平。----罪恶坑小程如是说</p></blockquote><p>既然选轮子的时间成本也不低, 那有时候我们可以自己造一个轮子。其实写一个的好处也多, 有成就感, 写好了可以吹牛逼, 写坏了填坑速度快。但问题是, 以前没写过怎么办？没把握怎么办？比如我们现在需要实现上面的文字效果, 但是又不知道怎么写, 怎么办？
没关系, 上帝创造世间也分了七步走, 跟着这位带头大哥后面学, 总不会错的。</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="开始">开始<a class="hash-link" href="#开始" title="Direct link to heading">​</a></h2><blockquote><p>罗马不是一天建成的, 毛片不是一次性拍完的 ----罪恶坑小程如是说</p></blockquote><p>咦, 好像扯得有点多了。对不起, 现在开始正式拍（苍老师准备下, 小程也准备下, Action）：</p><h4 class="anchor anchorWithStickyNavbar_mojV" id="1-分解任务">1. 分解任务<a class="hash-link" href="#1-分解任务" title="Direct link to heading">​</a></h4><p>通过简单观察我们可以马上知道, 上面那个动画效果是通过对每个字符做动画完成的。而在iOS里, 文本显示控件最常见和常用的是UILabel。而iOS的Explicit Animation有Properties Animation和keyframe Animation两种。</p><p>但是UILabel控件没有提供对其Text中每个字符的控制的功能, 我们需要改造下。既然要对每个字符做动画, 那少不了需要<code>frame</code>, <code>bounds</code>, <code>position</code>, <code>transform</code>, 这些属性。
这样看来我们需要两个武器：一个做排版功能的framework, 不用说, 肯定是<a href="http://objccn.io/issue-5-1/" target="_blank" rel="noopener noreferrer">TextKit</a>。而另一个是能显示单个字符也拥有<code>frame</code>, <code>bounds</code>, <code>position</code>, <code>transform</code>等属性的类, 很自然, 我们想到<code>CATextLayer</code>。</p><h4 class="anchor anchorWithStickyNavbar_mojV" id="2-先解决文本布局">2. <strong>先解决文本布局</strong><a class="hash-link" href="#2-先解决文本布局" title="Direct link to heading">​</a></h4><p>TextKit里主要是三个类<code>NSTextStorage</code>, <code>NSLayoutManager</code>, <code>NSContainer</code>。它们一起帮组我们解决文字布局, 排版的工作。</p><ul><li><strong>NSTextStorage</strong>：<code>NSMutableAttributedString</code>的子类, 持有文字内容, 当字符发生改变时, 通知<code>NSLayoutManager</code>对象</li><li><strong>NSLayoutManager</strong>: 我们的男主角, 从<code>NSTextStorage</code>里获取文字内容后, 转换成对应的glyph, 根据<code>NSTextContainer</code>的visible Region显示glyph。</li><li><strong>NSContainer</strong>: 确定一个region来laid out text。这个region被<code>NSLayoutManager</code>用来决定哪里可以break lines</li></ul><p>不过可惜UILabel没有这三个类作为自己的属性对象, 我们需要自己解决：</p><div class="codeBlockContainer_I0IT language-swift theme-code-block"><div class="codeBlockContent_wNvx swift"><pre tabindex="0" class="prism-code language-swift codeBlock_jd64 thin-scrollbar" style="color:#F8F8F2;background-color:#282A36"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#F8F8F2"><span class="token plain">class TextAnimationLabel: UILabel,NSLayoutManagerDelegate {   </span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">     let textStorage:NSTextStorage = NSTextStorage(string: "")</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">     let textLayoutManager:NSLayoutManager = NSLayoutManager()</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">     let textContainer:NSTextContainer = NSTextContainer()</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>除此以外我们还需要两个Array用来保存文本变换前的旧字符和变换后的新字符:</p><div class="codeBlockContainer_I0IT language-swift theme-code-block"><div class="codeBlockContent_wNvx swift"><pre tabindex="0" class="prism-code language-swift codeBlock_jd64 thin-scrollbar" style="color:#F8F8F2;background-color:#282A36"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#F8F8F2"><span class="token plain">var oldCharacterTextLayers:[CATextLayer] = [] </span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">var newCharacterTextLayers:[CATextLayer] = []</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>因为我们需要用我们自己的textStorage对象, 所以我们需要覆盖text和attributedText等属性。</p><div class="codeBlockContainer_I0IT language-swift theme-code-block"><div class="codeBlockContent_wNvx swift"><pre tabindex="0" class="prism-code language-swift codeBlock_jd64 thin-scrollbar" style="color:#F8F8F2;background-color:#282A36"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#F8F8F2"><span class="token plain">override var text:String! {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    get {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        return super.text</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    set {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        super.text = text</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        let attributedText = NSMutableAttributedString(string: newValue)</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        let textRange = NSMakeRange(0,newValue.characters.count)</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        attributedText.setAttributes([NSForegroundColorAttributeName:self.textColor], range: textRange)</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        attributedText.setAttributes([NSFontAttributeName:self.font], range: textRange)</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        let paragraphyStyle = NSMutableParagraphStyle()</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        paragraphyStyle.alignment = self.textAlignment</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        attributedText.addAttributes([NSParagraphStyleAttributeName:paragraphyStyle], range: textRange)</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        self.attributedText = attributedText</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        </span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain"> }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    </span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">override var attributedText:NSAttributedString! {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    get {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        return self.textStorage as NSAttributedString</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    set{</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        cleanOutOldCharacterTextLayers()</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        oldCharacterTextLayers = Array(newCharacterTextLayers)</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        textStorage.setAttributedString(newValue)</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        self.startAnimation { () -&gt; () in</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">            self.endAnimation(nil)</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>当TextStorage的文本内容改变时, 会触发一个通知send textLayoutManager以便重新布局排版。显然我们可以在排版布局完成后来为每个字符创建设置一个CATextLayer, 并设置相应的frame以便正确的显示内容。我们可以有个函数来完成计算。并且layout finish完成时调用。</p><div class="codeBlockContainer_I0IT language-swift theme-code-block"><div class="codeBlockContent_wNvx swift"><pre tabindex="0" class="prism-code language-swift codeBlock_jd64 thin-scrollbar" style="color:#F8F8F2;background-color:#282A36"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#F8F8F2"><span class="token plain">    // Mark:NSLayoutMangerDelegate</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    func layoutManager(layoutManager: NSLayoutManager, didCompleteLayoutForTextContainer textContainer: NSTextContainer?, atEnd layoutFinishedFlag: Bool) {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">            calculateTextLayers()</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">            print("\(textStorage.string)")</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        </span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        </span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    // MARK:CalculateTextLayer</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    func calculateTextLayers()</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    }</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>接下来我们的主要想法, 是找到text里每个character以及对应的glyph rect.然后用character和glyph rect创建CATextLayer</p><p>首先我们要有一个空数组用来存放新的CATextLayer。并且获取textStorage的attributedText。</p><div class="codeBlockContainer_I0IT language-swift theme-code-block"><div class="codeBlockContent_wNvx swift"><pre tabindex="0" class="prism-code language-swift codeBlock_jd64 thin-scrollbar" style="color:#F8F8F2;background-color:#282A36"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#F8F8F2"><span class="token plain">func calculateTextLayers()</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">{</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain"> newCharacterTextLayers.removeAll(keepCapacity:false)</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain"> let attributedText = textStorage.string</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>接下来我们要通过LayoutManger找到TextContainer的used Rect, 这样方便我们可以让文本垂直居中, 就像普通的Label那样。</p><div class="codeBlockContainer_I0IT language-swift theme-code-block"><div class="codeBlockContent_wNvx swift"><pre tabindex="0" class="prism-code language-swift codeBlock_jd64 thin-scrollbar" style="color:#F8F8F2;background-color:#282A36"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#F8F8F2"><span class="token plain">func calculateTextLayers()</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">{</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain"> newCharacterTextLayers.removeAll(keepCapacity:false)</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain"> let attributedText = textStorage.string</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain"> let wordRange = NSMakeRange(0, attributedText.characters.count)</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    let attributedString = self.internalAttributedText();</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    let layoutRect = textLayoutManager.usedRectForTextContainer(textContainer)</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    var index = wordRange.location</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    let totalLength = NSMaxRange(wordRange)</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    while index &lt; totalLength {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">         ...</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>现在我们开始迭代处理文本里的每个字符, 创建一个glyphRange 并且用这个glyphRange找到对应的character, 然后我们将glyph index丢给LayoutManager得到textContainer, 再用container和glyphRange取得glyphRect(这里需要注意下kerning的问题)。</p><div class="codeBlockContainer_I0IT language-swift theme-code-block"><div class="codeBlockContent_wNvx swift"><pre tabindex="0" class="prism-code language-swift codeBlock_jd64 thin-scrollbar" style="color:#F8F8F2;background-color:#282A36"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#F8F8F2"><span class="token plain">let glyphRange = NSMakeRange(index, 1)</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">let characterRange = textLayoutManager.characterRangeForGlyphRange(glyphRange, actualGlyphRange: nil)</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">let textContainer = textLayoutManager.textContainerForGlyphAtIndex(index, effectiveRange: nil)</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">var glyphRect = textLayoutManager.boundingRectForGlyphRange(glyphRange, inTextContainer: textContainer!)</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>最终我们还需要注意的就是glyph的kerning, 如果kerningRange.location == index, 我们需要将前一个textLayer取出来调整其Rect的宽度至新的glyphRect的最右边, 保证glyph不会被裁切掉（可以对比下面两张图片）</p><p><img src="https://cloud.githubusercontent.com/assets/3759810/13854816/4a6b5258-eca8-11e5-9870-15ed2d4f0d70.png" alt="img"></p><p><img src="https://cloud.githubusercontent.com/assets/3759810/13854821/4c5b947e-eca8-11e5-811e-e9abb161345f.png" alt="img"></p><div class="codeBlockContainer_I0IT language-swift theme-code-block"><div class="codeBlockContent_wNvx swift"><pre tabindex="0" class="prism-code language-swift codeBlock_jd64 thin-scrollbar" style="color:#F8F8F2;background-color:#282A36"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#F8F8F2"><span class="token plain">let kerningRange = textLayoutManager.rangeOfNominallySpacedGlyphsContainingIndex(index)</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">if kerningRange.location == index &amp;&amp; kerningRange.length &gt; 1 {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        if newCharacterTextLayers.count &gt; 0 {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">            //如果前一个textlayer的frame.size.width不变大的话, 当前的textLayer会遮挡住字体的一部分, 比如“Yes”的Y右上角会被切掉一部分</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">                            let previousLayer = newCharacterTextLayers[newCharacterTextLayers.endIndex - 1]</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">                            var frame = previousLayer.frame</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">                    frame.size.width += CGRectGetMaxX(glyphRect) - CGRectGetMaxX(frame)</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">                    previousLayer.frame = frame</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">     }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>这里关于kerning和glyph要多说一点。先来说下glyph, 简单来说glyph是表示一个character的具体样式,但他们却不是一一对应的关系, 比如一个字母"A"可以有不同的写法来表示例如：</p><p><img src="https://cloud.githubusercontent.com/assets/3759810/13878224/e142bef8-ed4a-11e5-9c84-798cb5939f36.png" alt="img"></p><p>除此以外, 还有这种情况：</p><p><img src="https://cloud.githubusercontent.com/assets/3759810/13878392/fab15e02-ed4b-11e5-9d38-2dc00ed45b0b.png" alt="img"></p><p>上面是的"ff"虽然是两个character, 但是glyph却是一个。
不过不用担心, 强大LayoutManager提供了两个方法帮助我们通过一个找到对应另外那个。</p><div class="codeBlockContainer_I0IT language-swift theme-code-block"><div class="codeBlockContent_wNvx swift"><pre tabindex="0" class="prism-code language-swift codeBlock_jd64 thin-scrollbar" style="color:#F8F8F2;background-color:#282A36"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#F8F8F2"><span class="token plain">    func characterIndexForGlyphAtIndex(_ glyphIndex: Int) -&gt; Int</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    func glyphIndexForCharacterAtIndex(_ charIndex: Int) -&gt; Int</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>现在我们说下kerning。通常, 在水平排布的文本中, glyph都是一个挨着一个放置的, 但是在某些时候为了让文本的可读性更好, 看上去更加优雅美观, 一个字形和另外一个字形之间可能会稍微的错位下, 比如下面这种情况：</p><p><img src="https://cloud.githubusercontent.com/assets/3759810/13878767/7631a33c-ed4e-11e5-9d03-46d89d8af9c8.png" alt="img"></p><p>这也是上面为什么”Y“会出现显示不全的原因了。</p><p>接下来就比较简单了, 创建Textlayer,设置垂直居中, 添加到数组当中, index+= characterRange.length, 开始下次循环</p><div class="codeBlockContainer_I0IT language-swift theme-code-block"><div class="codeBlockContent_wNvx swift"><pre tabindex="0" class="prism-code language-swift codeBlock_jd64 thin-scrollbar" style="color:#F8F8F2;background-color:#282A36"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#F8F8F2"><span class="token plain">glyphRect.origin.y += (self.bounds.size.height/2)-(layoutRect.size.height/2)</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">let textLayer = CATextLayer(frame: glyphRect, string: attributedString.attributedSubstringFromRange(characterRange));</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">layer.addSublayer(textLayer);</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">newCharacterTextLayers.append(textLayer);</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">index += characterRange.length</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><h4 class="anchor anchorWithStickyNavbar_mojV" id="3-动画实现">3. <strong>动画实现</strong><a class="hash-link" href="#3-动画实现" title="Direct link to heading">​</a></h4><p>上面我们解决了字符排版的问题, 接下来动画的实现就相对的容易了, 仔细观察那个动画, 很容易得出主要是对<code>opacity </code>和<code>transform</code>两个属性做属性动画, <code>opacity</code>让每个字体逐渐显示和逐渐消失, 而<code>transform</code>则做了两种变形, 一种是往下移动,另外一种是旋转。用<code>CABasicAnimation</code>可以解决单个属性动画, 而<code>CAAnimationGroup</code>则帮我们解决多个动画叠加的复合效果。</p><div class="codeBlockContainer_I0IT theme-code-block"><div class="codeBlockContent_wNvx"><pre tabindex="0" class="prism-code language-text codeBlock_jd64 thin-scrollbar" style="color:#F8F8F2;background-color:#282A36"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#F8F8F2"><span class="token plain">func groupAnimationWithLayerChanges(old olderLayer:CALayer, new newLayer:CALayer) -&gt; CAAnimationGroup? {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    var animationGroup:CAAnimationGroup?</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    var animations:[CABasicAnimation] = [CABasicAnimation]()</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    if !CATransform3DEqualToTransform(olderLayer.transform,</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    newLayer.transform) {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">         let basicAnimation = CABasicAnimation(keyPath: "transform")</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">         basicAnimation.fromValue = NSValue(CATransform3D: olderLayer.transform)</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">         basicAnimation.toValue = NSValue(CATransform3D: newLayer.transform)</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">         animations.append(basicAnimation)</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">         }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    if olderLayer.opacity != newLayer.opacity {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">       let basicAnimation = CABasicAnimation(keyPath: "opacity")</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">       basicAnimation.fromValue = olderLayer.opacity</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">       basicAnimation.toValue = newLayer.opacity</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">       animations.append(basicAnimation)</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">       }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    if animations.count &gt; 0 {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">       animationGroup = CAAnimationGroup()</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">       animationGroup!.animations = animations</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">   }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>这里需要注意一个问题, 就是隐式动画的问题, Core Animation基于一个假说, 就是屏幕上的任何东西都可以(或者可能)做动画, 我们平时在写代码时应该有这种印象就是你只是layer设置了一个值, 没有添加动画, 但是你会看到一个平滑过渡的显示效果而不是非常突兀的变化。这就是隐式动画。当我们改变一个属性时, Core Animation帮我们做了一个动画, 动画时间取决于当前NSTransaction的设置, 而动画类型取决于图层行为。</p><p>这里有个有趣的东西, 多说一点, 就是当我们对UIView关联的图层做动画而不是一个单独的图层做动画, 比如</p><div class="codeBlockContainer_I0IT language-swift theme-code-block"><div class="codeBlockContent_wNvx swift"><pre tabindex="0" class="prism-code language-swift codeBlock_jd64 thin-scrollbar" style="color:#F8F8F2;background-color:#282A36"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#F8F8F2"><span class="token plain">func changeColor()</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">{</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    CATransaction.begin();</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    CATransaction.setAnimationDuration(1.0)</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    CGFloat red = CGFloat(arc4random() / (CGFloat)INT_MAX);</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    CGFloat green = CGFloat(arc4random() / (CGFloat)INT_MAX);</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    CGFloat blue = CGFloat(arc4random() / (CGFloat)INT_MAX);</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    self.layerView.layer.backgroundColor = UIColor.(colorWithRed:red green:green blue:blue alpha:1.0).CGColor;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    CATransaction.commit();</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>图层的颜色瞬间切换到新的值, 而不是之前的平滑过渡, 隐式动画似乎给关闭了。
我们知道UIView和CALayer最重要的关系就是UIView是CALayer的delegate,
当我们改变CALayer的属性时, 它会调用 <code>func actionForKey(_ event: String) -&gt; CAAction?</code> 这个方法, 接下来发生的事情在官方文档里都有写, 实际上是如下几步:</p><ul><li><p><em>If the layer has a delegate that implements the actionForLayer:forKey: method, the layer calls that method. The delegate must do one of the following:</em></p><div class="codeBlockContainer_I0IT theme-code-block"><div class="codeBlockContent_wNvx"><pre tabindex="0" class="prism-code language-text codeBlock_jd64 thin-scrollbar" style="color:#F8F8F2;background-color:#282A36"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#F8F8F2"><span class="token plain">1. Return the action object for the given key.</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">2. Return the NSNull object if it does not handle the action.</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div></li><li><p><em>The layer looks in the layer’s actions dictionary for a matching key/action pair.</em></p></li><li><p><em>The layer looks in the style dictionary for an actions dictionary for a matching key/action pair.</em></p></li><li><p><em>The layer calls the defaultActionForKey: class method to look for any class-defined actions.</em></p></li></ul><p>UIView作为它关联图层的Delegate, 实现了 <code>actionForLayer(_ layer: CALayer, forKey event: String) -&gt; CAAction?</code> , 当不在一个动画块中, UIView返回nil, 而在动画块中则返回一个非空值</p><div class="codeBlockContainer_I0IT language-swift theme-code-block"><div class="codeBlockContent_wNvx swift"><pre tabindex="0" class="prism-code language-swift codeBlock_jd64 thin-scrollbar" style="color:#F8F8F2;background-color:#282A36"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#F8F8F2"><span class="token plain">print("OutSide:\(self.view.actionForLayer(self.view.layer, forKey: "backgroundColor"))")</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">UIView.beginAnimations(nil, context: nil)</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">print("InSide:\(self.view.actionForLayer(self.view.layer,</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">forKey: "backgroundColor"))")</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">UIView.commitAnimations()</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>显示结果如下</p><div class="codeBlockContainer_I0IT language-swift theme-code-block"><div class="codeBlockContent_wNvx swift"><pre tabindex="0" class="prism-code language-swift codeBlock_jd64 thin-scrollbar" style="color:#F8F8F2;background-color:#282A36"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#F8F8F2"><span class="token plain">OutSide:Optional(&lt;null&gt;)</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">InSide:Optional(&lt;CABasicAnimation: 0x7f7f93ff81b0&gt;)</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>当然返回nil并不是禁用隐式动画的唯一方法, 下面这样也行</p><div class="codeBlockContainer_I0IT theme-code-block"><div class="codeBlockContent_wNvx"><pre tabindex="0" class="prism-code language-text codeBlock_jd64 thin-scrollbar" style="color:#F8F8F2;background-color:#282A36"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#F8F8F2"><span class="token plain">CATransaction.setDisableActions(true)</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>那为什么说这个问题呢？因为我们在对每个字符做动画的时候需要先将隐式动画关闭, 否者将会做两次动画, 比如下面这样:</p><p><img src="https://cloud.githubusercontent.com/assets/3759810/13857496/2443d70a-ecb5-11e5-8661-a499e9c8719d.gif" alt="closeimplicitanimation"></p><p>那么, 我们先生成一份oldlayer,然后改变相应的属性, 生产新的newLayer。然后创建相应的动画组, 添加显式动画。</p><div class="codeBlockContainer_I0IT language-swift theme-code-block"><div class="codeBlockContent_wNvx swift"><pre tabindex="0" class="prism-code language-swift codeBlock_jd64 thin-scrollbar" style="color:#F8F8F2;background-color:#282A36"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#F8F8F2"><span class="token plain">let olderLayer = animationObjc.animatableLayerCopy(layer)</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">CATransaction.begin()</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">CATransaction.setDisableActions(true)</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">newLayer = effectAnimationClosure(layer: layer)</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">CATransaction.commit()</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">var animationGroup:CAAnimationGroup?</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">animationGroup = groupAnimationWithLayerChanges(old: olderLayer, new: newLayer!)</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">layer.addAnimation(textAniamtionGroup, forKey: textAnimationGroupKey)</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><h2 class="anchor anchorWithStickyNavbar_mojV" id="收工">收工<a class="hash-link" href="#收工" title="Direct link to heading">​</a></h2><p>好了, 当上面所有的工作完成之后, 就是我们最开始看到的那个效果, 代码已经上传github, 你可以从<a href="https://github.com/OnePieceLv/TextKitAndAnimationEffect.git" target="_blank" rel="noopener noreferrer">这里</a>下载。其实这个demo里实现的label还有很大优化的空间。比如支持多种类型的动画效果, 动画效果可配置等等。这是我接下来打算做的事情。
本人才疏学浅, 错漏难免, 欢迎大家批评指正以及 pull request ：）。</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="最后">最后<a class="hash-link" href="#最后" title="Direct link to heading">​</a></h2><p>不知不觉工作许多年了, 这几年萝莉变成了姑娘, 姑娘变成了孩子妈。大家从QQ空间杀到朋友圈。从晒女朋友, 到晒结婚照继而到晒娃。这几年鸣人同志都不负众望当上了火影(丫也不请吃饭)。大家都在发生变化。
学会开始写点东西分享可能是我想要的一个变化。</p><p>参考资料：</p><ul><li><p><a href="https://github.com/zipme/RQShineLabel.git" target="_blank" rel="noopener noreferrer">RQShineLabel</a>这个作者是直接对字体的alpha值做属性动画。没有给字体做重新布局。动画是用CADisplayLink实现, 跟LTMorphingLabel一样。</p></li><li><p><a href="http://swiftyeti.com/texteffects-with-nslayoutmanager/" target="_blank" rel="noopener noreferrer">TextEffects with NSLayoutManager</a></p></li><li><p><a href="https://developer.apple.com/videos/play/wwdc2013/220/" target="_blank" rel="noopener noreferrer">Advanced Text Layouts and Effects with Text Kit</a></p></li><li><p><a href="https://github.com/lexrus/LTMorphingLabel.git" target="_blank" rel="noopener noreferrer">LTMorphingLabel</a></p></li></ul>]]></content:encoded>
        </item>
    </channel>
</rss>